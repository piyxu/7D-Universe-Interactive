<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>7D Universe: From Space to Rules</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #fff;
            overflow-x: hidden;
        }
        
        .license {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 10px;
            color: #888;
            z-index: 1000;
            max-width: 220px;
        }
        
        .license a {
            color: #00d9ff;
            text-decoration: none;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #00d9ff;
            margin: 30px 0;
            font-size: 36px;
        }
        
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 40px;
            font-size: 16px;
        }
        
        .dimension-grid {
            display: grid;
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .dimension-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border-left: 5px solid;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .dimension-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 217, 255, 0.3);
        }
        
        .dim-123 { border-color: #ff6b6b; }
        .dim-4 { border-color: #f9ca24; }
        .dim-5 { border-color: #a29bfe; }
        .dim-6 { border-color: #00d9ff; }
        .dim-7 { border-color: #fd79a8; }
        
        .dimension-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .dimension-number {
            font-size: 48px;
            font-weight: bold;
            margin-right: 20px;
            opacity: 0.3;
        }
        
        .dimension-title {
            font-size: 24px;
            font-weight: bold;
        }
        
        .dimension-question {
            font-size: 18px;
            color: #00d9ff;
            font-style: italic;
            margin-bottom: 10px;
        }
        
        .dimension-desc {
            font-size: 14px;
            line-height: 1.8;
            color: #ccc;
        }
        
        .dimension-example {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 3px solid rgba(255, 255, 255, 0.2);
        }
        
        .example-title {
            color: #f9ca24;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .canvas-container {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            margin: 40px 0;
            border: 2px solid rgba(0, 217, 255, 0.3);
        }
        
        canvas {
            width: 100%;
            height: 500px;
            border-radius: 10px;
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .controls {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border: 2px solid rgba(0, 217, 255, 0.3);
        }
        
        .control-group {
            margin: 20px 0;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: #00d9ff;
            font-weight: bold;
        }
        
        .control-value {
            background: rgba(0, 217, 255, 0.2);
            padding: 5px 12px;
            border-radius: 5px;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d9ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d9ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
            border: none;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        button {
            background: linear-gradient(135deg, #00d9ff 0%, #0098c7 100%);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            flex: 1;
            min-width: 120px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 217, 255, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .info-box {
            background: rgba(162, 155, 254, 0.1);
            border: 2px solid #a29bfe;
            border-radius: 10px;
            padding: 20px;
            margin: 30px 0;
        }
        
        .info-title {
            color: #a29bfe;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .key-insight {
            background: rgba(249, 202, 36, 0.1);
            border-left: 4px solid #f9ca24;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 28px;
            }
            
            canvas {
                height: 300px;
            }
            
            .dimension-number {
                font-size: 36px;
            }
            
            .dimension-title {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="license">
        MIT License ¬© 2024<br>
        By Mesut Erturhan<br>
        with <a href="https://claude.ai" target="_blank">Claude</a> (Anthropic)<br>
        <a href="#license-full">View Full License</a>
    </div>
    
    <div class="container">
        <h1>üåå 7-Dimensional Universe</h1>
        <div class="subtitle">From Physical Space to Universal Rules</div>
        
        <div class="info-box">
            <div class="info-title">üìñ Understanding Reality Through Dimensions</div>
            <p style="line-height: 1.8; color: #ccc;">
                Most people know about 3D space and time. But what if reality has more layers? 
                This visualization explores a 7-dimensional model where each dimension answers a fundamental question about existence.
                Use the interactive controls below to explore how different dimensions interact.
            </p>
        </div>
        
        <div class="dimension-grid">
            <div class="dimension-card dim-123">
                <div class="dimension-header">
                    <div class="dimension-number">1-3</div>
                    <div>
                        <div class="dimension-title">SPACE</div>
                        <div class="dimension-question">"Where?"</div>
                    </div>
                </div>
                <div class="dimension-desc">
                    The three spatial dimensions we experience every day: length, width, and height. 
                    These define physical location in the universe.
                </div>
                <div class="dimension-example">
                    <div class="example-title">Example:</div>
                    A point in space: (X: 10m, Y: 5m, Z: 3m)
                </div>
            </div>
            
            <div class="dimension-card dim-4">
                <div class="dimension-header">
                    <div class="dimension-number">4</div>
                    <div>
                        <div class="dimension-title">TIME</div>
                        <div class="dimension-question">"When?"</div>
                    </div>
                </div>
                <div class="dimension-desc">
                    The temporal dimension. Events unfold in time, creating causality and change. 
                    Past ‚Üí Present ‚Üí Future defines the arrow of time.
                </div>
                <div class="dimension-example">
                    <div class="example-title">Example:</div>
                    An apple falls from a tree at t=0, hits the ground at t=2 seconds
                </div>
            </div>
            
            <div class="dimension-card dim-5">
                <div class="dimension-header">
                    <div class="dimension-number">5</div>
                    <div>
                        <div class="dimension-title">BRANCHING / PROBABILITY</div>
                        <div class="dimension-question">"Which reality?"</div>
                    </div>
                </div>
                <div class="dimension-desc">
                    Quantum branching - every decision or quantum event creates parallel realities. 
                    This dimension represents which branch of reality you're experiencing.
                </div>
                <div class="dimension-example">
                    <div class="example-title">Example:</div>
                    You roll a die:<br>
                    ‚Ä¢ Reality A: you rolled a 1<br>
                    ‚Ä¢ Reality B: you rolled a 2<br>
                    ‚Ä¢ Reality C: you rolled a 3...<br>
                    All exist simultaneously in different 5D locations
                </div>
            </div>
            
            <div class="dimension-card dim-6">
                <div class="dimension-header">
                    <div class="dimension-number">6</div>
                    <div>
                        <div class="dimension-title">PROBABILITY DISTRIBUTION</div>
                        <div class="dimension-question">"How likely?"</div>
                    </div>
                </div>
                <div class="dimension-desc">
                    The shape of probability itself. While 5D determines which outcome happened, 
                    6D determines how likely each outcome was. Think of it as the "thickness" of reality branches.
                </div>
                <div class="dimension-example">
                    <div class="example-title">Example:</div>
                    Two dice scenarios:<br>
                    ‚Ä¢ Fair die: each number has 16.67% chance (uniform distribution)<br>
                    ‚Ä¢ Loaded die: 6 has 50% chance, others 10% each (skewed distribution)<br>
                    <br>
                    6D determines which scenario you're in
                </div>
            </div>
            
            <div class="dimension-card dim-7">
                <div class="dimension-header">
                    <div class="dimension-number">7</div>
                    <div>
                        <div class="dimension-title">RULES / LAWS</div>
                        <div class="dimension-question">"What's possible?"</div>
                    </div>
                </div>
                <div class="dimension-desc">
                    The fundamental laws of physics themselves. This dimension determines what can and cannot happen - 
                    the rules of the game. Different positions in 7D mean different physical constants and laws.
                </div>
                <div class="dimension-example">
                    <div class="example-title">Example:</div>
                    In our universe (7D position A):<br>
                    ‚Ä¢ Speed of light = 300,000 km/s<br>
                    ‚Ä¢ Standard die has 6 sides<br>
                    ‚Ä¢ Time flows forward<br>
                    ‚Ä¢ Rolling a 7 is impossible<br>
                    <br>
                    In another universe (7D position B):<br>
                    ‚Ä¢ Speed of light = 150,000 km/s<br>
                    ‚Ä¢ Die could have 8 sides<br>
                    ‚Ä¢ Time might flow differently<br>
                    ‚Ä¢ Rolling a 7 becomes possible
                </div>
            </div>
        </div>
        
        <div class="key-insight">
            <strong>üéØ Key Insight:</strong> Each dimension constrains the next:<br>
            ‚Ä¢ 7D sets what's possible (rules)<br>
            ‚Ä¢ 6D sets how probable outcomes are (distribution)<br>
            ‚Ä¢ 5D selects which outcome occurred (branching)<br>
            ‚Ä¢ 4D places it in time (when)<br>
            ‚Ä¢ 1-3D places it in space (where)
        </div>
        
        <div class="canvas-container">
            <h2 style="color: #00d9ff; margin-bottom: 20px; text-align: center;">
                Interactive 7D Visualization
            </h2>
            <canvas id="universeCanvas"></canvas>
            <p style="text-align: center; color: #888; margin-top: 15px; font-size: 14px;">
                Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Use controls below to navigate dimensions
            </p>
        </div>
        
        <div class="controls">
            <h3 style="color: #00d9ff; margin-bottom: 20px;">üéõÔ∏è Dimension Controls</h3>
            
            <div class="control-group">
                <div class="control-label">
                    <span>‚è∞ Time (4D)</span>
                    <span class="control-value" id="timeValue">0.0s</span>
                </div>
                <input type="range" id="timeSlider" min="0" max="100" value="0" step="1">
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <span>üåø Reality Branch (5D)</span>
                    <span class="control-value" id="branchValue">Branch A</span>
                </div>
                <input type="range" id="branchSlider" min="0" max="100" value="50" step="1">
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <span>üìä Probability Distribution (6D)</span>
                    <span class="control-value" id="probValue">Uniform</span>
                </div>
                <input type="range" id="probSlider" min="0" max="100" value="50" step="1">
            </div>
            
            <div class="control-group">
                <div class="control-label">
                    <span>‚öñÔ∏è Physics Rules (7D)</span>
                    <span class="control-value" id="rulesValue">Standard Physics</span>
                </div>
                <input type="range" id="rulesSlider" min="0" max="100" value="50" step="1">
            </div>
            
            <div class="button-group">
                <button id="playBtn">‚ñ∂Ô∏è Animate Time</button>
                <button id="randomBtn">üé≤ Random Universe</button>
                <button id="resetBtn">üîÑ Reset</button>
            </div>
        </div>
        
        <div class="info-box">
            <div class="info-title">üß† Philosophical Implications</div>
            <p style="line-height: 1.8; color: #ccc; margin-bottom: 15px;">
                If this 7D model is correct, it means:
            </p>
            <ul style="line-height: 2; color: #ccc; margin-left: 20px;">
                <li><strong>Free will (5D):</strong> You don't choose which branch - all branches exist</li>
                <li><strong>Destiny (6D):</strong> Some futures are more "probable" but all exist</li>
                <li><strong>Multiverse (7D):</strong> Infinite universes with different physics</li>
                <li><strong>You (1-4D):</strong> Experience one path through this 7D space</li>
            </ul>
        </div>
        
        <div id="license-full" style="background: rgba(0,0,0,0.5); padding: 30px; border-radius: 10px; margin: 40px 0; font-size: 12px; color: #888; line-height: 1.8;">
            <h3 style="color: #00d9ff; margin-bottom: 15px;">MIT License</h3>
            <p>Copyright (c) 2024 Mesut Erturhan</p>
            <p style="margin: 10px 0;">Created in collaboration with Claude (Anthropic AI Assistant)</p>
            <p style="margin-top: 15px;">
                Permission is hereby granted, free of charge, to any person obtaining a copy
                of this software and associated documentation files (the "Software"), to deal
                in the Software without restriction, including without limitation the rights
                to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                copies of the Software, and to permit persons to whom the Software is
                furnished to do so, subject to the following conditions:
            </p>
            <p style="margin-top: 15px;">
                The above copyright notice and this permission notice shall be included in all
                copies or substantial portions of the Software.
            </p>
            <p style="margin-top: 15px;">
                THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                SOFTWARE.
            </p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const canvas = document.getElementById('universeCanvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 15, 60);
        
        const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
        camera.position.set(20, 15, 20);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);
        
        const pointLight1 = new THREE.PointLight(0x00d9ff, 1.5, 100);
        pointLight1.position.set(15, 15, 15);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xa29bfe, 1, 80);
        pointLight2.position.set(-15, -10, -15);
        scene.add(pointLight2);
        
        const pointLight3 = new THREE.PointLight(0xf9ca24, 0.8, 60);
        pointLight3.position.set(0, 20, 0);
        scene.add(pointLight3);
        
        // State variables
        let timeValue = 0;
        let branchLayer = 0.5;
        let probabilityDist = 0.5;
        let rulesSet = 0.5;
        let isPlaying = false;
        
        let universeNodes = [];
        let universeConnections = [];
        
        // Create universe tree structure
        function createUniverseTree() {
            // Clear previous
            universeNodes.forEach(node => scene.remove(node));
            universeConnections.forEach(line => scene.remove(line));
            universeNodes = [];
            universeConnections = [];
            
            // Origin point
            const originGeom = new THREE.SphereGeometry(0.5, 16, 16);
            const originMat = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0x00d9ff,
                emissiveIntensity: 0.5
            });
            const origin = new THREE.Mesh(originGeom, originMat);
            origin.position.set(0, 0, 0);
            origin.userData = { time: 0, branch: 0.5, prob: 0.5, rules: rulesSet };
            scene.add(origin);
            universeNodes.push(origin);
            
            // Recursive branching
            function createBranch(startPos, startTime, startBranch, startProb, depth, maxDepth) {
                if (depth >= maxDepth) return;
                
                const numBranches = depth === 0 ? 3 : 2;
                const timeStep = 2.5;
                const currentTime = startTime + timeStep;
                
                // Rules affect branch behavior
                const rulesFactor = Math.abs(rulesSet - 0.5) * 2; // 0 to 1
                const branchSpread = 2 + rulesFactor * 2; // Rules change how universe branches
                
                for (let i = 0; i < numBranches; i++) {
                    const angle = (i / numBranches) * Math.PI * 2 + Math.random() * 0.5;
                    
                    // Branch layer changes based on choice
                    const newBranch = startBranch + (Math.random() - 0.5) * 0.3;
                    const clampedBranch = Math.max(0, Math.min(1, newBranch));
                    
                    // Probability affects thickness
                    const probVariation = (Math.random() - 0.5) * 0.2;
                    const newProb = Math.max(0, Math.min(1, startProb + probVariation));
                    
                    const endPos = new THREE.Vector3(
                        startPos.x + Math.cos(angle) * branchSpread,
                        startPos.y + currentTime * 0.9,
                        startPos.z + Math.sin(angle) * branchSpread
                    );
                    
                    // Node color based on dimensions
                    const hue = (clampedBranch * 0.6 + rulesSet * 0.4);
                    const saturation = 0.7 + newProb * 0.3;
                    const lightness = 0.5;
                    
                    const nodeColor = new THREE.Color().setHSL(hue, saturation, lightness);
                    const nodeSize = 0.25 + newProb * 0.25; // Probability affects size
                    
                    const nodeGeom = new THREE.SphereGeometry(nodeSize, 12, 12);
                    const nodeMat = new THREE.MeshPhongMaterial({
                        color: nodeColor,
                        emissive: nodeColor,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.9
                    });
                    const node = new THREE.Mesh(nodeGeom, nodeMat);
                    node.position.copy(endPos);
                    node.userData = { 
                        time: currentTime, 
                        branch: clampedBranch,
                        prob: newProb,
                        rules: rulesSet
                    };
                    scene.add(node);
                    universeNodes.push(node);
                    
                    // Connection line
                    const lineGeom = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
                    const lineWidth = 0.5 + newProb; // Probability affects line thickness (visual only)
                    const lineMat = new THREE.LineBasicMaterial({
                        color: nodeColor,
                        transparent: true,
                        opacity: 0.4 + newProb * 0.3
                    });
                    const line = new THREE.Line(lineGeom, lineMat);
                    line.userData = { prob: newProb, branch: clampedBranch };
                    scene.add(line);
                    universeConnections.push(line);
                    
                    // Recursive
                    createBranch(endPos, currentTime, clampedBranch, newProb, depth + 1, maxDepth);
                }
            }
            
            createBranch(new THREE.Vector3(0, 0, 0), 0, 0.5, probabilityDist, 0, 4);
            
            // Add coordinate axes
            const axesHelper = new THREE.AxesHelper(20);
            scene.add(axesHelper);
            
            // Add grid
            const gridHelper = new THREE.GridHelper(40, 40, 0x444444, 0x222222);
            scene.add(gridHelper);
        }
        
        createUniverseTree();
        
        // Update visualization based on dimension values
        function updateVisualization() {
            universeNodes.forEach(node => {
                const timeDiff = Math.abs(node.userData.time - timeValue);
                const branchDiff = Math.abs(node.userData.branch - branchLayer);
                const probDiff = Math.abs(node.userData.prob - probabilityDist);
                const rulesDiff = Math.abs(node.userData.rules - rulesSet);
                
                // Multi-dimensional visibility
                const timeVisible = timeDiff < 4;
                const branchVisible = branchDiff < 0.35;
                const probVisible = probDiff < 0.4;
                const rulesVisible = rulesDiff < 0.3;
                
                if (timeVisible && branchVisible && probVisible && rulesVisible) {
                    node.visible = true;
                    const opacity = (1 - timeDiff/4) * (1 - branchDiff/0.35) * (1 - probDiff/0.4);
                    node.material.opacity = Math.max(0.3, opacity);
                    
                    // Scale based on probability
                    const scale = 1 + (1 - probDiff/0.4) * 0.5;
                    node.scale.setScalar(scale);
                    
                    // Pulse based on rules
                    const pulse = Math.sin(Date.now() * 0.002 * (1 + rulesDiff)) * 0.2 + 1;
                    node.material.emissiveIntensity = 0.3 * pulse;
                } else {
                    node.visible = false;
                }
            });
            
            universeConnections.forEach(line => {
                const probDiff = Math.abs(line.userData.prob - probabilityDist);
                const branchDiff = Math.abs(line.userData.branch - branchLayer);
                
                const visible = probDiff < 0.4 && branchDiff < 0.35;
                line.visible = visible;
                if (visible) {
                    line.material.opacity = Math.max(0.2, 0.6 - probDiff - branchDiff);
                }
            });
        }
        
        // Mouse controls
        let mouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        
        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!mouseDown) return;
            
            const deltaX = e.clientX - mouseX;
            const deltaY = e.clientY - mouseY;
            
            const radius = Math.sqrt(
                camera.position.x ** 2 + 
                camera.position.y ** 2 + 
                camera.position.z ** 2
            );
            
            const theta = Math.atan2(camera.position.z, camera.position.x);
            const phi = Math.acos(camera.position.y / radius);
            
            const newTheta = theta + deltaX * 0.01;
            const newPhi = Math.max(0.1, Math.min(Math.PI - 0.1, phi + deltaY * 0.01));
            
            camera.position.x = radius * Math.sin(newPhi) * Math.cos(newTheta);
            camera.position.y = radius * Math.cos(newPhi);
            camera.position.z = radius * Math.sin(newPhi) * Math.sin(newTheta);
            
            camera.lookAt(0, 0, 0);
            
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY * 0.01;
            const radius = Math.sqrt(
                camera.position.x ** 2 + 
                camera.position.y ** 2 + 
                camera.position.z ** 2
            );
            const newRadius = Math.max(10, Math.min(60, radius + delta));
            const scale = newRadius / radius;
            camera.position.multiplyScalar(scale);
        });
        
        // UI Controls
        const timeSlider = document.getElementById('timeSlider');
        const branchSlider = document.getElementById('branchSlider');
        const probSlider = document.getElementById('probSlider');
        const rulesSlider = document.getElementById('rulesSlider');
        
        const timeValueDisplay = document.getElementById('timeValue');
        const branchValueDisplay = document.getElementById('branchValue');
        const probValueDisplay = document.getElementById('probValue');
        const rulesValueDisplay = document.getElementById('rulesValue');
        
        const playBtn = document.getElementById('playBtn');
        const randomBtn = document.getElementById('randomBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        timeSlider.addEventListener('input', (e) => {
            timeValue = parseFloat(e.target.value) / 10;
            timeValueDisplay.textContent = timeValue.toFixed(1) + 's';
            updateVisualization();
        });
        
        branchSlider.addEventListener('input', (e) => {
            branchLayer = parseFloat(e.target.value) / 100;
            const branches = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            const index = Math.floor(branchLayer * (branches.length - 1));
            branchValueDisplay.textContent = 'Branch ' + branches[index];
            updateVisualization();
        });
        
        probSlider.addEventListener('input', (e) => {
            probabilityDist = parseFloat(e.target.value) / 100;
            const states = ['Heavy Skew', 'Skewed', 'Uniform', 'Mixed', 'Balanced'];
            const index = Math.floor(probabilityDist * (states.length - 1));
            probValueDisplay.textContent = states[index];
            updateVisualization();
        });
        
        rulesSlider.addEventListener('input', (e) => {
            const oldRules = rulesSet;
            rulesSet = parseFloat(e.target.value) / 100;
            const rules = ['Exotic Physics', 'Altered Laws', 'Standard Physics', 'Modified Constants', 'Strange Universe'];
            const index = Math.floor(rulesSet * (rules.length - 1));
            rulesValueDisplay.textContent = rules[index];
            
            // Regenerate if rules changed significantly
            if (Math.abs(oldRules - rulesSet) > 0.15) {
                createUniverseTree();
            }
            updateVisualization();
        });
        
        playBtn.addEventListener('click', () => {
            isPlaying = !isPlaying;
            playBtn.textContent = isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Animate Time';
        });
        
        randomBtn.addEventListener('click', () => {
            timeSlider.value = Math.random() * 100;
            branchSlider.value = Math.random() * 100;
            probSlider.value = Math.random() * 100;
            rulesSlider.value = Math.random() * 100;
            
            timeSlider.dispatchEvent(new Event('input'));
            branchSlider.dispatchEvent(new Event('input'));
            probSlider.dispatchEvent(new Event('input'));
            rulesSlider.dispatchEvent(new Event('input'));
        });
        
        resetBtn.addEventListener('click', () => {
            isPlaying = false;
            timeSlider.value = 0;
            branchSlider.value = 50;
            probSlider.value = 50;
            rulesSlider.value = 50;
            
            playBtn.textContent = '‚ñ∂Ô∏è Animate Time';
            timeSlider.dispatchEvent(new Event('input'));
            branchSlider.dispatchEvent(new Event('input'));
            probSlider.dispatchEvent(new Event('input'));
            rulesSlider.dispatchEvent(new Event('input'));
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (isPlaying) {
                timeValue += 0.05;
                if (timeValue > 10) timeValue = 0;
                timeSlider.value = timeValue * 10;
                timeValueDisplay.textContent = timeValue.toFixed(1) + 's';
                updateVisualization();
            }
            
            // Particle effects
            universeNodes.forEach(node => {
                if (node.visible) {
                    node.rotation.y += 0.01;
                    const pulse = Math.sin(Date.now() * 0.003 + node.position.x) * 0.15 + 1;
                    node.material.emissiveIntensity = 0.3 * pulse;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        animate();
        updateVisualization();
        
        // Responsive
        window.addEventListener('resize', () => {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });
    </script>
</body>
</html>